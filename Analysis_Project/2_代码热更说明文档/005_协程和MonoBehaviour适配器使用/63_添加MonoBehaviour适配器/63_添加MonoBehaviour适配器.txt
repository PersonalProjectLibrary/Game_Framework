类似协程适配器讲解，这里只是做简单讲解。
根据官方文档提醒，最好/百分比不要去写去使用MonoBehaviour适配器。
MonoBehaviour的内容函数特别多，去写适配器要写超级大量的代码，
特别是工程里大量使用到MonoBehaviour时，去写对应适配器就是很疯狂的事。
这里也就简单的写：Start、Awake、Update几个方法函数的适配器。

一、Unity主工程里写协程适配器类和协程适配器类型类：
在ILRuntimeManager.cs文件里，ILRuntimeManager{}外面，
跨域委托、继承适配器、CLR功能、协程适配器测试代码模块里添加协程适配器的类
添加协程适配器的类：CoroutineAdapter(){} 与Adaptor(){}

public class MonoBehaviourAdapter : CrossBindingAdaptor
{
    public override System.Type BaseCLRType{ get { return typeof(MonoBehaviour); } }//返回要继承的类
    public override System.Type AdaptorType{ get { return typeof(Adapter); } }//返回适配器
    public override object CreateCLRInstance(AppDomain appdomain, ILTypeInstance instance)
    {
        return new Adapter(appdomain, instance);//返回适配器实例化
    }
    public class Adapter: MonoBehaviour,CrossBindingAdaptorType
    {
        private AppDomain m_AppDomain;
        private ILTypeInstance m_Instance;

        private IMethod m_ToString;
        private IMethod m_AwakeMethod;
        private IMethod m_StartMethod;
        private IMethod m_UpdateMethod;

        public Adapter() { }
        public Adapter(AppDomain appdomain, ILTypeInstance instance)
        {
            m_AppDomain = appdomain;
            m_Instance = instance;
        }
        // 对应MonoBehaviour的实例，可get，也可set
        public ILTypeInstance ILInstance
        {
            get { return m_Instance; }
            set
            {
                m_Instance = value;
                //实例修改后，原方法函数要重置，避免还是使用之前实例的同名方法函数
                m_AwakeMethod = null;
                m_StartMethod = null;
                m_UpdateMethod = null;
            }
        }
        // 提供可更改程序集的属性，可get，可set
        public AppDomain AppDomain
        {
            get { return m_AppDomain; }
            set { m_AppDomain =  value; }
        }
        public override string ToString()
        {
            if (m_ToString == null) m_ToString = m_AppDomain.ObjectType.GetMethod("ToString", 0);
            IMethod m = m_Instance.Type.GetVirtualMethod(m_ToString);
            if (m == null || m is ILMethod) return m_Instance.ToString();
            else return m_Instance.Type.FullName;
        }
        public void Awake()
        {
            if (m_Instance != null)//Awake执行的比较早，可能存在实例为空的情况
            {
                if (m_AwakeMethod == null) m_AwakeMethod = m_Instance.Type.GetMethod("Awake", 0);
                if(m_AwakeMethod != null)m_AppDomain.Invoke(m_AwakeMethod,m_Instance,null);
            }
        }
        public void Start()
        {
            //前面有Awake先执行判断实例是否存在，这里不用再判断m_Instance是否为空了
            if (m_StartMethod == null) m_StartMethod = m_Instance.Type.GetMethod("Start", 0);
            if (m_StartMethod != null) m_AppDomain.Invoke(m_StartMethod, m_Instance, null);
        }
        public void Update()
        {
            if (m_UpdateMethod == null) m_UpdateMethod = m_Instance.Type.GetMethod("Update", 0);
            if (m_UpdateMethod != null) m_AppDomain.Invoke(m_UpdateMethod, m_Instance, null);
        }
    }
}

二、热更工程HotFix新建测试MonoBehaviour适配器的类：TestMonoBehaviour.cs
1、新建TestMonoBehaviour.cs类：
解决方案--选中HotFix右键--添加新项--类：TestMonoBehaviour.cs
生成的新类，类名处，删除关键字：internal，添加public

2、完善MonoBehaviour测试类TestMonoBehaviour.cs里的方法
namespace HotFix
{
    public class TestMono
    {
        //执行这个方法，就可以自动执行MonoTest里的Awake、Start、Update方法
        public static void RunTest(GameObject go){ go.AddComponent<TestMonoBehaviour>(); }
    }
    public class TestMonoBehaviour : MonoBehaviour
    {
        public float m_CurTime = 0;
        void Awake(){ Debug.Log("MonoTest Awake!"); }
        void Start(){ Debug.Log("MonoTest Start!"); }
        void Update()
        {
            if (m_CurTime < 0.2f)
            {
                Debug.Log("MonoTest Update!");
                m_CurTime += Time.deltaTime;
            }
        }
        public static void RunTest(GameObject go){ Debug.Log("MonoTest RunTest"); }
    }
}

三、重定向处理
1、HotFix工程测试代码中使用到AddComponent<MonoTest>，而MonoTest这个类不在Unity主工程中
直接AddComponet<MonoTest>是加不到Object身上去的，所以要做重定向，
2、在ILRuntimeManager.cs类里写方法SetupCLRRedirection()，
将HotFix工程里的AddComponent进行一个挟持，转换成Unity工程那边的调用；
3、写完方法后，在InitializeILRuntime()方法里进行调用执行。
CLR的重定向注册也要放在CLR绑定注册前执行。
4、重定向方法函数：SetupCLRRedirection()和AddCompontent()函数
（1）注：视频课程里SetupCLRRedirection()前面不加unsafe关键词，
导致进行重定向：m_AppDomain.RegisterCLRMethodRedirection(method,AddCompontent);这里一直报错：
Pointers and fixed size buffers may only be used in an unsafe context。
即：指针和固定大小的缓冲区只能在不安全的上下文中使用
SetupCLRRedirection()和AddCompontent()函数前面都要加关键词“unsafe”!!!

（2）
unsafe void SetupCLRRedirection()
{
    //先获取GameObject这个类型，然后获取GameObject里的函数方法
    var arr = typeof(GameObject).GetMethods();
    foreach (var method in arr)//遍历GameObject里的函数方法
    {
        //找只有一个参数的AddComponet方法
        if(method.Name =="AddComponent"&& method.GetGenericArguments().Length == 1)
        {
            //使用热更程序集对AddComponent进行重定向成目标函数
            m_AppDomain.RegisterCLRMethodRedirection(method,AddCompontent);
        }
    }
}
//用到指针写的不安全委托,参数可以直接拷贝官方文档的重定向示例里给的写法
private unsafe StackObject* AddCompontent(ILIntepreter __intp, StackObject* __esp, List<object> __mStack, CLRMethod __method, bool isNewObj)
{
    AppDomain __domain = __intp.AppDomain;//获取到程序集
    var ptr = __esp - 1;//获取第一个参数
    GameObject instance = StackObject.ToObject(ptr, __domain, __mStack) as GameObject;//获取第一个参数的值
    if (instance == null) throw new System.Exception();
    __intp.Free(ptr);//获取完参数，释放指针
    var genericArgument = __method.GenericArguments;//获取所有泛型变量
    //AddComponent只有一个参数，对应泛型变量长度为1
    if (genericArgument != null && genericArgument.Length == 1)
    {
        var type = genericArgument[0];//找到目标函数，进行获取
        object res;
        if (type is CLRType) //CLRType说明是Unity主工程里的类型，不需要做处理
        {
            res = instance.AddComponent(type.TypeForCLR);
        }
        else //ILType说明是热更工程里的类型，需要做重定向
        {
            //实例化热更dll里的类，传false表手动创建类，Unity不允许new一个MonoBehaviour类
            var ilInstance = new ILTypeInstance(type as ILType, false);
            //创建适配器实例，把GameObject添加上了适配器;后面根据适配器里的类来掉热更里的目标类
            var clrInstance = instance.AddComponent<MonoBehaviourAdapter.Adapter>();
            //因为Unity里写的适配器类clrInstance里没有对应的热更类，要做实例的替换，手动赋值
            clrInstance.ILInstance = ilInstance;//实例替换
            clrInstance.AppDomain = __domain;//程序集也替换
            //默认创建的CLRInstance不是通过AddCompontent出来的有效实例，用下面的实例替换
            ilInstance.CLRInstance = clrInstance;//Instance转换替换
            res = clrInstance.ILInstance;//转换好了进行赋值
            clrInstance.Awake();//真正调用MonoBehaviour的Awake函数，补掉Awake();
        }
        return ILIntepreter.PushObject(ptr, __mStack, res);
    }
    return __esp;
}

四、Unity工程里在ILRuntimeManager的InitializeILRuntime()方法里注册协程适配器：
void InitializeILRuntime()
{
     ... ...
    //MonoBehaviour测试适配器注册
    m_AppDomain.RegisterCrossBindingAdaptor(new MonoBehaviourAdapter());
    //MonoBehaviour测试里需要的CLR重定向
    SetupCLRRedirection();
    //CLR绑定注册（放最后执行）
    ILRuntime.Runtime.Generated.CLRBindings.Initialize(m_AppDomain);
}
注：放在CLR绑定注册语句的前面注册，CLR绑定注册最后执行。

五、Unity工程里ILRuntimeCLRBinding.cs的InitILRuntime()里
取消对MonoBehaviour适配器的注释/添加协程适配器的注册语句：
static void InitILRuntime(ILRuntime.Runtime.Enviorment.AppDomain domain)
{
    //注册适配器
    ////这里需要注册所有热更DLL中用到的跨域继承Adapter，否则无法正确抓取引用
    //domain.RegisterCrossBindingAdaptor(new WindowAdapter());
    domain.RegisterCrossBindingAdaptor(new InheritanceAdapter());
    domain.RegisterCrossBindingAdaptor(new CoroutineAdapter());
    domain.RegisterCrossBindingAdaptor(new MonoBehaviourAdapter());
}

六、Unity工程里ILRuntimeManager.cs里OnHotFixLoaded()里执行MonoBehaviour的测试语句
void OnHotFixLoaded()
{
     ... ...
    //MonoBehaviour测试
    m_AppDomain.Invoke("HotFix.TestMono", "RunTest", null, GameStart.Instance.gameObject);
}

七、更新dll
1、HotFix热更工程生成dll；
2、Unity里点击菜单栏“更新Hotfix的dll”更新dll；

八、进行CLR代码生成绑定
点击菜单栏“ILRuntime/Generate CLR Binding Code by Analysis”

九、点击运行，查看控制台输出：
MonoTest Awake!
MonoTest Start!
MonoTest Update!